### نظرة تنفيذية مختصرة
- الهدف: إعداد خطة احترافية قابلة للتنفيذ لتعظيم الاستفادة من منصتك الحالية (Django + PostgreSQL + Redis + RQ) مع واجهة Vite + Vue 3، تشمل تحسين البنية، الأداء، الأمان، التجربة، الأوفلاين، والـ CI/CD.
- نطاق التدقيق: يشمل كل شيء في المنصة: الباك-إند، الفرونت-إند، قواعد البيانات، السكربتات التشغيلية، خطوط البناء والنشر، المراقبة والـ RBAC.
- مخرجات هذا المستند: خطة شاملة كملف MD تنفيذي يتضمن مهام دقيقة، مسارات ملفات مقترحة، مؤشرات نجاح، وقوالب PR/Issue.

---

### لقطة حالية (استنادًا إلى الملفات المتاحة)
- سكربتات تطوير:
  - `scripts/dev_setup.ps1`: تهيئة بيئة Python، venv، فحوص `black/flake8` وتشغيل مولد `gen_index.py --check`.
  - `scripts/dev_up.ps1`: يضمن Postgres + Redis عبر Docker، يطبّق ترحيلات Django، يجهّز Superuser، يُطلق عامل `RQ` وسيرفر HTTPS (Uvicorn TLS)، ويفتح `healthz` و`/admin`.
  - `scripts/dev_all.ps1`: يشغّل الباك-إند ثم ينتظر `livez`، وبعدها يبدأ Vite Dev Server للفرونت-إند (يتحقق من حزم مثل `@tanstack/vue-query` و`vue-toastification`).
  - `scripts/rq_worker.ps1`: عامل مهام RQ مع فحص اتصال Redis وترحيلات قبل التشغيل.
  - `scripts/full_audit.ps1`: فحوص Django النظامية، حالة الترحيلات، و`healthcheck` نصي.
- استنتاجات:
  - البنية جاهزة للتطوير المحلي مع صحة وTLS وفصل للنوافذ.
  - Redis وRQ مستخدمان لمهام الخلفية (إشعارات/تقارير محتملة).
  - هناك نية لوجود فرونت حديث (Vue Query/Toast) حتى لو لم تُعرض مصادره هنا.

---

### خارطة طريق طبقية
- طبقة الواجهة: Vue 3 + Vite + Pinia + Vue Router + Vue Query + i18n + PWA + Toasts.
- طبقة الخدمات: Axios + Interceptors (JWT/Refresh) + Socket/WebSocket.
- طبقة الأعمال: وحدات `attendance`, `grades`, `timetable`, `notifications`, `users`.
- طبقة الـ API: Django REST Framework + RBAC دقيق + فهارس DB + مهام RQ.
- طبقة البنية: Dockerized Postgres/Redis، شهادة TLS dev، CI/CD، مراقبة، نسخ احتياطي.

---

### خطة تدقيق وتنفيذ مرحلية (قابلة للتنفيذ خلال 2–3 أسابيع)

#### المرحلة 0 — التحقق السريع وتشغيل البيئة
- مهام:
  - تشغيل: `scripts/dev_up.ps1` ثم `scripts/dev_all.ps1` للتأكد من عمل الباك-إند والفرونت.
  - صحّة: تأكيد `http://127.0.0.1:8000/healthz` و`https://127.0.0.1:8443/livez` وسير العامل `rq_worker`.
  - توثيق: تحديث `README.md` بقسم “التشغيل السريع” يقتبس هذه السكربتات.
- مؤشرات النجاح:
  - Health 200/204 + Admin يفتح.
  - Redis وRQ يعملان، وسجلات العامل تظهر الاتصال.

#### المرحلة 1 — حوكمة الشفرة والمعمارية
- فرونت-إند:
  - بنية مجلدات موحدة داخل `frontend/src`:
    - `app/` (`main.ts`, `router.ts`, `i18n.ts`, `pwa.ts`)
    - `services/` (`http.ts`, `auth.ts`, `rbac.ts`, `socket.ts`)
    - `modules/attendance|grades|timetable|notifications|users/`
    - `shared/` (مكونات/أدوات/أنواع)
  - إضافة/تثبيت الحزم: `pinia`, `vue-router@4`, `@tanstack/vue-query`, `vue-i18n`, `vee-validate`, `zod`, `vue-toastification`, `vite-plugin-pwa`.
  - إعداد `Axios` مع Interceptors وRefresh (JWT أو Session): ملف `services/http.ts` كما ناقشنا سابقًا.
- باك-إند:
  - اعتماد DRF بشكل صريح: `djangorestframework`، وتفعيل `DEFAULT_AUTHENTICATION_CLASSES`.
  - توحيد المصادقة: `rest_framework_simplejwt` أو جلسات + CSRF. الموصى: Access JWT بالذاكرة + Refresh كـ `HttpOnly`.
  - RBAC: تثبيت نموذج أذونات يغطي الوحدات: `attendance:*`, `grades:*`, `timetable:*`, `notifications:*`.
- أدوات الجودة:
  - Python: `black`, `flake8`, `isort`, `mypy` (اختياري)، أُدرجت جزئيًا بالفعل.
  - Frontend: `eslint` + `@typescript-eslint` + `prettier` + قواعد Vue.
- مؤشرات النجاح:
  - تشغيل فرونت/باك بإعدادات موحّدة وموثّقة، مع تخطّي أخطاء لِنتر أساسية.

#### المرحلة 2 — i18n + RTL + الوصولية
- i18n:
  - `app/i18n.ts` مع `ar` افتراضي و`en` احتياطي.
  - جعل `dir="rtl"` ديناميكيًا عند اختيار `ar`.
- RTL:
  - Tailwind RTL أو إعداد Vuetify/Element Plus بـ `rtl: true`.
- A11y:
  - مراجعة التباين، الانتقال بالكيبورد، ARIA labels، التركيز داخل الـ Modals.
- مؤشرات النجاح:
  - تعريب كامل، اتجاه صحيح بدون انعكاسات غير مقصودة.

#### المرحلة 3 — وحدة الحضور كطيّار End‑to‑End
- بيانات ونمذجة:
  - جدول `Attendance(student_id, class_id, date, status[present|absent|late], note, recorded_by, created_at)` مع فهارس `(class_id, date)` و`(student_id, date)`.
- API DRF:
  - `GET /api/attendance?date=YYYY-MM-DD&classId=...`
  - `POST /api/attendance { date, classId, studentId, status }`
  - صلاحيات: `attendance:read`, `attendance:write`.
- مهام RQ:
  - عند غياب/تأخر: جدولة رسالة إشعار لولي الأمر أو تلخيص يومي.
- فرونت-إند:
  - `modules/attendance/api.ts`, `useAttendance.ts` (Vue Query مع تفاؤل)، `components/AttendanceTable.vue` لإدخال سريع، اختصارات P/A/L.
- أوفلاين/PWA:
  - `vite-plugin-pwa` + Workbox مع Background Sync أو Queue IndexedDB لطلبات `POST /attendance`.
- Realtime:
  - Django Channels + Redis أو إشعارات عبر RQ → WebSocket: بث `attendance:updated` لتحديث شاشات المعلمين.
- اختبارات:
  - Backend: اختبارات API/Permissions/Serializers.
  - Frontend: `vitest` + `@vue/test-utils` للمكونات، وسيناريوهات Cypress.
- مؤشرات النجاح:
  - تحميل قائمة الطلاب < 1s بعد التخزين.
  - إدخال فوري بلا تأخير ملحوظ؛ عند الانقطاع يستمر ويزامن لاحقًا.

#### المرحلة 4 — الدرجات والجداول والإشعارات
- Grades (Workflow): `draft → pending_approval → published` مع RBAC وسجل تدقيق.
- Timetable: CRUD مبسط + فلاتر حسب الصف/المعلم/المادة.
- Notifications: نموذج `Notification(to_user, title, body, read)` + قناة WebSocket + Badge/Toasts في الفرونت.
- مؤشرات النجاح:
  - نشر الدرجات يتم بموافقة، إشعارات ترسل لحظيًا.

#### المرحلة 5 — الأمان والمراقبة
- مصادقة:
  - Access قصيرة العمر، Refresh آمن (Cookie HttpOnly)، منع التخزين الطويل في LocalStorage.
- CSRF/XSS:
  - إنفاذ CSRF للجلسات، وتعقيم الحقول الغنية.
- سجلات وهيكلة:
  - Logging JSON مع `request_id`، Sentry للباك والفرونت.
- Health/Ready:
  - استمرار `/healthz` و`/livez` والاستفادة منهما في CI/المنصة.
- نسخ احتياطي:
  - نسخ PostgreSQL مجدول، مراقبة Redis.
- مؤشرات النجاح:
  - تقارير أخطاء ذات أثر عملي، وامتثال أمني أساسي.

#### المرحلة 6 — الأداء
- Backend:
  - فهارس محسّنة، `select_related/prefetch_related` لتجنب N+1، caching للثوابت.
- Frontend:
  - Lazy routes/components، إعداد `staleTime/cacheTime`، استخدام `select` لـ Vue Query لتقليل الأحمال.
- أصول:
  - Brotli/Gzip، `rollup-plugin-visualizer` لتحليل الباندل.
- مؤشرات النجاح:
  - زمن API شائع < 200ms، TTI منخفض، انخفاض حجم الباندل.

#### المرحلة 7 — CI/CD واختبارات تلقائية
- GitHub Actions:
  - Backend: `black --check`, `flake8`, اختبارات Django، `scripts/full_audit.ps1`.
  - Frontend: `eslint`, `vitest`, `npm run build`.
  - Artefacts: رفع `dist` وتقارير الاختبارات.
- CD:
  - Frontend: Vercel/Netlify أو Nginx داخل Docker.
  - Backend: Render/Railway/DO + Postgres مُدار.
- مؤشرات النجاح:
  - كل Push يبني ويختبر ويُنتج معاينات.

---

### بنى ملفات مقترحة وقوالب

#### فرونت-إند: شجرة ملفات
```
frontend/src/
  app/
    main.ts
    router.ts
    i18n.ts
    pwa.ts
  services/
    http.ts
    auth.ts
    rbac.ts
    socket.ts
  modules/
    attendance/
      api.ts
      useAttendance.ts
      components/
        AttendanceTable.vue
      pages/
        AttendancePage.vue
    grades/
    timetable/
    notifications/
    users/
  shared/
    components/
    utils/
    types/
```

#### Axios Interceptors (JWT Refresh)
```ts
// frontend/src/services/http.ts
import axios from 'axios'
import { useAuthStore } from '@/modules/users/store'

export const http = axios.create({ baseURL: import.meta.env.VITE_API_URL })

http.interceptors.request.use((config) => {
  const auth = useAuthStore()
  if (auth.accessToken) config.headers.Authorization = `Bearer ${auth.accessToken}`
  return config
})

let refreshing: Promise<string | null> | null = null
http.interceptors.response.use(
  (res) => res,
  async (error) => {
    const auth = useAuthStore()
    const original: any = error.config
    if (error.response?.status === 401 && !original._retry) {
      original._retry = true
      refreshing = refreshing ?? auth.refreshToken()
      const newToken = await refreshing.finally(() => (refreshing = null))
      if (newToken) {
        original.headers.Authorization = `Bearer ${newToken}`
        return http(original)
      }
    }
    return Promise.reject(error)
  }
)
```

#### Router Guards + RBAC
```ts
// frontend/src/app/router.ts
import { createRouter, createWebHistory } from 'vue-router'
import { useAuthStore } from '@/modules/users/store'

const routes = [
  { path: '/login', component: () => import('@/modules/users/pages/Login.vue') },
  { path: '/', component: () => import('@/modules/home/Dashboard.vue'), meta: { requiresAuth: true } },
  { path: '/attendance', component: () => import('@/modules/attendance/pages/AttendancePage.vue'), meta: { requiresAuth: true, perm: 'attendance:write' } },
]

export const router = createRouter({ history: createWebHistory(), routes })

router.beforeEach((to) => {
  const auth = useAuthStore()
  if (to.meta.requiresAuth && !auth.isAuthenticated) return '/login'
  if (to.meta.perm && !auth.hasPermission(to.meta.perm as string)) return '/'
})
```

#### Attendance: Vue Query Hook
```ts
// frontend/src/modules/attendance/useAttendance.ts
import { useQuery, useMutation, useQueryClient } from '@tanstack/vue-query'
import { fetchAttendance, markAttendance } from './api'

export function useAttendance(date: string, classId: string) {
  const qc = useQueryClient()
  const qKey = ['attendance', date, classId]

  const list = useQuery({ queryKey: qKey, queryFn: () => fetchAttendance(date, classId), staleTime: 60_000 })

  const mutate = useMutation({
    mutationFn: markAttendance,
    onMutate: async (payload) => {
      await qc.cancelQueries({ queryKey: qKey })
      const prev = qc.getQueryData<any>(qKey)
      qc.setQueryData(qKey, (old: any) => old.map((s: any) => s.studentId === payload.studentId ? { ...s, status: payload.status, _optimistic: true } : s))
      return { prev }
    },
    onError: (_err, _vars, ctx) => { if (ctx?.prev) qc.setQueryData(qKey, ctx.prev) },
    onSettled: () => { qc.invalidateQueries({ queryKey: qKey }) },
  })

  return { list, mutate }
}
```

#### Django DRF مثال سريع (مبسط)
```py
# backend/attendance/api.py
from rest_framework import viewsets, permissions
from .models import Attendance
from .serializers import AttendanceSerializer

class CanReadAttendance(permissions.BasePermission):
    def has_permission(self, request, view):
        return request.user.has_perm('attendance.read')

class CanWriteAttendance(permissions.BasePermission):
    def has_permission(self, request, view):
        if request.method in ['POST', 'PUT', 'PATCH']:
            return request.user.has_perm('attendance.write')
        return True

class AttendanceViewSet(viewsets.ModelViewSet):
    serializer_class = AttendanceSerializer
    queryset = Attendance.objects.all()
    permission_classes = [CanReadAttendance & CanWriteAttendance]

    def get_queryset(self):
        qs = super().get_queryset()
        date = self.request.query_params.get('date')
        class_id = self.request.query_params.get('classId')
        if date: qs = qs.filter(date=date)
        if class_id: qs = qs.filter(class_id=class_id)
        return qs
```

---

### خطة الأوفلاين وPWA
- PWA: `vite-plugin-pwa` بإعداد `registerType: 'autoUpdate'`, `manifest` بخصائص عربية.
- Caching: Workbox `globPatterns` للأصول، و`Background Sync` أو Queue mutations لعمليات `POST` للحضور.
- تجربة: إشارة حالة الاتصال، طابور متزامن، تخفيف تعارضات (merge server state بعد العودة).

---

### المراقبة والقياس
- Sentry: SDK للباك والفرونت مع `release` و`environment`.
- Logging JSON: Django مع `request_id` في كل سجل.
- Health: إبقاء `/healthz` و`/livez` ضمن لوح مراقبة CI وبيئة الإنتاج.

---

### الأمن والامتثال
- JWT Refresh عبر Cookie HttpOnly، تقصير عمر Access، تدوير Refresh.
- CORS مصفّى، سياسات `Content-Security-Policy`, `Referrer-Policy`.
- Sanitization للمدخلات المعروضة HTML، وحدود معدلات (DRF throttling) لنقاط حساسة.

---

### الأداء: قواعد عملية
- Backend: فهارس حيث تستخدم فلاتر متكررة، واعتماد `select_related`.
- Frontend: تقسيم شيفرة المسارات الكبيرة، استخدام `defineAsyncComponent` للمكونات الثقيلة.
- أصول: مراقبة حجم الحزمة عبر `rollup-plugin-visualizer`.

---

### CI/CD: مثال سير عمل مختصر
```yaml
# .github/workflows/ci.yml
name: ci
on: [push, pull_request]
jobs:
  backend:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with: { python-version: '3.11' }
      - run: pip install -r requirements.txt
      - run: scripts/full_audit.ps1
        shell: pwsh
      - run: python -m pytest
  frontend:
    runs-on: ubuntu-latest
    defaults: { run: { working-directory: frontend } }
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with: { node-version: '20' }
      - run: npm ci
      - run: npm run lint
      - run: npm run test
      - run: npm run build
      - uses: actions/upload-artifact@v4
        with: { name: dist, path: frontend/dist }
```

---

### لوح تنفيذ بالمهام وقبولها
- إنشاء Issues/Tasks مفصّلة:
  - FR-001: تهيئة بنية `frontend/src` وإعداد الحزم الأساسية.
  - BE-001: تفعيل DRF + JWT/Session موحّد + RBAC للأذونات.
  - ATT-001: API الحضور + اختبارات.
  - ATT-002: واجهة الحضور + Vue Query + اختصارات + Toasts.
  - PWA-001: تفعيل PWA + Offline Queue للحضور.
  - RT-001: قنال WebSocket وبث تحديثات الحضور.
  - SEC-001: سياسات CORS/CSP، إعدادات JWT آمنة.
  - OBS-001: تكامل Sentry، Logging JSON.
  - PERF-001: فهارس DB وتحسين ORM.
  - CI-001: سير CI في GitHub Actions للباك والفرونت.
- معايير القبول لكل مهمة تشمل: تغطية اختبار، لِنتر نظيف، قياسات زمن/حجم محددة.

---

### مخاطر وتخفيفها
- تعارضات حالة عند الأوفلاين: اعتماد "آخر كتابة تفوز" مع سجل تدقيق وتنبيه المستخدم.
- تسرب توكنات: حفظ Access في الذاكرة، وRefresh في HttpOnly فقط.
- تضخم الباندل: قواعد ESM وقطع ديناميكي للمسارات الثقيلة فقط.

---

### مؤشرات نجاح عامة (KPIs)
- زمن فتح شاشة الحضور الأولى < 1.5s على جهاز متوسط.
- زمن استجابة API الشائعة < 200ms (P50)، < 400ms (P95).
- نسبة أخطاء Sentry الشهرية أقل من 1% من الجلسات.
- نجاح مزامنة الأوفلاين للحضور > 99%.

---

### خطة زمنية مختصرة
- أسبوع 1: حوكمة + مصادقة + i18n/RTL.
- أسبوع 2: الحضور End‑to‑End + PWA/Offline + Realtime.
- أسبوع 3: الدرجات/الجداول + الأمان/المراقبة + CI/CD وتحسينات الأداء.

---

### تعليمات تشغيل سريعة للمطورين
- إعداد البيئة:
  - `scripts/dev_setup.ps1` ثم `scripts/dev_up.ps1`.
  - لتشغيل الباك والفرونت معًا: `scripts/dev_all.ps1`.
  - تشغيل عامل RQ منفصلًا: `scripts/rq_worker.ps1 -Queue default`.
- تدقيق شامل: `scripts/full_audit.ps1`.

---

### ما نحتاجه لتخصيص أدق
- تأكيد وضع المصادقة الحالي (JWT أم جلسات) ووجود DRF.
- قائمة الوحدات المفعّلة فعليًا في المنصة الآن.
- أي قيود إنتاج/استضافة لتكييف CI/CD وسياسات الأمان.

إذا رغبت، أزودك بقالب جاهز `README_audit.md` يتضمن الأقسام أعلاه لتضمينه مباشرة في المستودع، مع روابط افتراضية للملفات/المهام التي ستنشأ لاحقًا.